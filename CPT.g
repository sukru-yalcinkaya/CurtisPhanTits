InfoCPT := NewInfoClass("InfoCPT");
SetInfoLevel(InfoCPT,1);
################################################################################
################################################################################
################################################################################
ds:=function(G)
# returns some generators of the derived subgroup of the group "G".

local l,i,z,g,h;

l:=[];
i:=1;
  for i in [1..75] do
    g:=PseudoRandom(G);
    h:=PseudoRandom(G);
    z:=g^(-1)*h^(-1)*g*h;
    l[i]:=z;
  od;
return l;
end;
################################################################################
################################################################################
################################################################################
invo:=function(l,id,Eo)
# returns an involution produced from a random element in the group generated
# by the list "l".
# We assume that the distribution of the elements of even order in the group
# is pretty high, which is the case for Lie type groups of odd characteristic.

local G,seek,g,finished;

G:=Group(l);
seek:=false;
  while not seek do
    g:=PseudoRandom(G);
    g:=g^Eo;
      if g=id then
        seek:=false;
      else
        finished:=false;
          while not finished do
            if g^2=id then
              return g;
            else
              g:=g^2;
            fi;
          od;
      fi;
  od;
end;
################################################################################
################################################################################
################################################################################
invoeven:=function(g,id)
# returns an involution produced from an element "g" of even order.
# It is known that "g" has even order for this function.

local finished;

finished:=false;
  while not finished do
    if g^2=id then
      return g;
    else
      g:=g^2;
    fi;
  od;
end;
################################################################################
################################################################################
################################################################################
isincenter:=function(g,l)
# returns the truth value whether the element "g" is in the center of the group
# generated by the list "l".

local found,i,n;

found:=false;
i:=1;
n:=Length(l);
  while not found and i<= n do
    if g*l[i] = l[i]*g then
      i:=i+1;
      found:=false;
    else
      return false;
    fi;
  od;
  if not found then
    return true;
  fi;
end;
################################################################################
################################################################################
################################################################################
pseudoinvo:=function(l,id,Eo)
# returns a pseudoinvolution in the group generated by the list "l".
# This function is mainly used in the groups SL2 or commuting products of SL2,
# it is also used in Sp2n to produce a pseudoinvolution to get SLn.

local G,found,g,finished;

G:=Group(l);
found:=false;
  while (not found) do
    g:=PseudoRandom(G);
    g:=g^Eo;
      if (g = id) or (g^2 = id) then
        found:=false;
      else
        finished:=false;
          while not finished do
            if (g <> id) and (g^2 <> id) and (g^4 = id) then
              if isincenter(g^2,l) then
                return g;
              else
                finished:=true;
              fi;
            else
              g:=g^2;
            fi;
          od;
      fi;
  od;
end;
################################################################################
################################################################################
################################################################################
isabelian:=function(l)
# returns the truth value whether the group generated by the list "l" is abelian.

local i,found;

i:=1;
found:=true;
  while (i <= Length(l)) and found do
    if isincenter(l[i],l) then
      found:=true;
      i:=i+1;
    else
      found:=false;
    fi;
  od;
return found;
end;
################################################################################
################################################################################
################################################################################
docommute:=function(l1,l2)
# returns
# true: if the groups generated by the lists "l1" and "l2" commute with each other.
# false: if they do not.

local result,i,j;

i:=1;
result:=false;
  while (not result) and (i<=Length(l1)) do
    j:=1;
      while (not result) and (j<=Length(l2)) do
        if l1[i]*l2[j]<>l2[j]*l1[i] then
          result:=true;
        else
          j:=j+1;
        fi;
      od;
    i:=i+1;
  od;
return not result;
end;
################################################################################
################################################################################
################################################################################
conjsub:=function(l,g)
#returns the conjugate of the list "l" by the group element "g".

local i,s;

s:=[];;
  for i in [1..Length(l)] do
    s[i]:=l[i]^g;
  od;
return s;
end;
################################################################################
################################################################################
################################################################################
normalclosure:=function(g,l)
# returns some generators of the group generated by some conjugates of the element "g".

local G,ll,i;

G:=Group(l);
ll:=[];
  for i in [1..20] do
    ll[i]:=g^PseudoRandom(G);
  od;
return ll;
end;
################################################################################
################################################################################
################################################################################
zeta0:=function(t,G,id,Eo)
# returns an image of the map zeta for the involution "t".

local x,y,seek;

seek:=false;
  while not seek do
    x:=PseudoRandom(G);
    y:=t*(t^x);
    y:=y^Eo;
      if y <> id then
        return invoeven(y,id);
      fi;
  od;
end;
################################################################################
################################################################################
################################################################################
cent:=function(t,G,id,Eo)
# Here, "G" is a group and "t" is a non-central involution in "G".
# This function returns some generators of the centralizer
# of "t" in "G", "C_G(t)", by using only the map "zeta_1".

local l,i,x,y,seek;

l:=[];
  for i in [1..20] do
    seek:=false;
      while not seek do
        x:=PseudoRandom(G);
        y:=t*(t^x);
          if y^Eo=id then
            l[i]:=(y^((Eo+1)/2))*(x^(-1));
            seek:=true;
          else
            seek:=false;
          fi;
      od;
  od;
return l;
end;
################################################################################
################################################################################
################################################################################
sl2s:=function(l,id,Eo)
# returns a list consisting of some generators which generates commuting product
# of SL2's in the group generated by the list "l".

local s,a,prosl2,i,found,t,v,c,f,d,ss;

s:=l;
a:=Group(l);
prosl2:=false;
  while not prosl2 do
    i:=1;
    found:=false;
      while not found and i<=100 do
        t:=invo(s,id,Eo);
          if isincenter(t,s) then
            i:=i+1;
          else
            found:=true;
          fi;
      od;
      if not found then
        prosl2:=true;
        return s;
      elif found then
        ss:=s;
        v:=cent(t,a,id,Eo);
        c:=Group(v);
        f:=ds(c);
        d:=Group(f);
        s:=ds(d);
        a:=Group(s);
          if isabelian(s) then
            return ss;
          fi;
      fi;
  od;
end;
################################################################################
################################################################################
################################################################################
sl2:=function(l,id,Eo)
# returns some generators of SL2 from the commuting product of (P)SL2s.
# It returns "false" if there is no SL2.

local k,r,finished,s,t,n,a,v,c,f,d,ss,confirmed,i,tt,vv,cc,ff,dd,sss;

finished:=false;
k:=1;
  while (not finished) and (k<=10) do
    r:=invo(l,id,Eo);
      if isincenter(r,l) then
        finished:=true;
      else
        k:=k+1;
      fi;
  od;
  if (not finished) then
    return false;
  else
    finished:=false;
    s:=l;
      while not finished do
        t:=pseudoinvo(s,id,Eo);
        n:=ds(Group(normalclosure(t,s)));
        a:=Group(n);
        v:=cent(t,Group(s),id,Eo);
        c:=Group(v);
        f:=ds(c);
        d:=Group(f);
        ss:=ds(d);
          if isabelian(ss) then
            confirmed:=false;
            i:=1;
              while not confirmed and i<=5 do
                tt:=pseudoinvo(n,id,Eo);
                vv:=cent(tt,a,id,Eo);
                cc:=Group(vv);
                ff:=ds(cc);
                dd:=Group(ff);
                sss:=ds(dd);
                  if not isabelian(sss) then
                    confirmed:=true;
                  else
                    i:=i+1;
                  fi;
              od;
              if not confirmed then
                return n;
              fi;
          else
            s:=n;
          fi;
      od;
  fi;
end;
################################################################################
################################################################################
################################################################################
rootsl2:=function(l,s,id,Eo)
# returns the truth value whether the group generated by the list "s" is a
# fundamental SL2-subgroup in the group generated by the list "l" together
# with the involution in it.

local i,t,c,d;

i:=invo(s,id,Eo);
t:=pseudoinvo(s,id,Eo);
c:=ds(Group(ds(Group(cent(i,Group(l),id,Eo)))));
d:=ds(Group(ds(Group(cent(t,Group(c),id,Eo)))));
  if docommute(d,s) then
    return [true,i];
  else
    return [false,id];
  fi;
end;
################################################################################
################################################################################
################################################################################
glueinvo:=function(l,s,i,id,Eo)
# This function constructs, if possible, an involution by using the map "zeta_0"
# which does not commute with the group generated by the list "s".
# It returns false if "l" generates Sp2n with n>2 since in these groups
# such an involution does not exist.

local G,found,j,k;

G:=Group(l);
found:=false;
k:=1;
  while not found and k<=200 do
    j:=zeta0(i,G,id,Eo);
      if (not isincenter(j,s)) then
        return j;
      else
        k:=k+1;
      fi;
  od;
  if (not found) then
    return false;
  fi;
end;
################################################################################
################################################################################
################################################################################
isclassicalinvo:=function(l,t,i,id,Eo)
# Here, "i" is a classical involution. This function  returns the list "L" where
# L[1]: the truth value whether the involution "t" is a classical involution
# in the group generated by the list "l".
# L[2]: If L[1] is true, then the conjugating element from "i" to "t". If L[1]
# is false, the it is set to be "id".


local G,finished,k,g,z,zz;

G:=Group(l);
finished:=false;
k:=1;
  while (not finished) and k<=100 do
    g:=PseudoRandom(G);
    z:=(t^g)*i;
    zz:=z^Eo;
      if zz = id then
        return [true,(g*z^((Eo+1)/2))^-1];
      else
        k:=k+1;
      fi;
  od;
  if not finished then
    return [false,id];
  fi;
end;
################################################################################
################################################################################
################################################################################
istrivialgroup:=function(l,id)
# checks whether the generated by the list "l" is identity by comparing random
# elements by the identity.

local G,decided,k,g;

G:=Group(l);
decided:=false;
k:=1;
  while (not decided) and k<=5 do
    g:=PseudoRandom(G);
      if g<>id then
        return false;
      else
        k:=k+1;
      fi;
  od;
  if not decided then
    return true;
  fi;
end;
################################################################################
################################################################################
################################################################################
twosl2:=function(l,id,Eo)
# returns the generators of the SL2's in the group generated by the list "l"
# which is known to be a commuting product of two SL2's. This function is
# used in orthogonal groups to construct SL2's in the centralizers. Also, in
# symplectic groups when we construct a long root SL2's.

local G,ll,t;

G:=Group(l);
ll:=[];
ll[1]:=sl2(l,id,Eo);
t:=pseudoinvo(ll[1],id,Eo);
ll[2]:=ds(Group(ds(Group(cent(t,G,id,Eo)))));
return ll;
end;
################################################################################
################################################################################
################################################################################
cptforspn:=function(l,k,i,id,Eo)
# returns an extended Curtis-Tits or Phan system for symplectic groups.
# Here, the list "k" is a list of generators of a long root SL2 subgroup in
# the group generated by "l" known to be Sp_2n for some n, and "i" is then
# central involution in this SL2.

local x,splist,involist,t,count,v,remained,finished,c,g,tt,sp4,ttt,ii,kk,found,iii;

x:=Group(l);
splist:=[];
involist:=[];
splist[1]:=k;
involist[1]:=i;
t:=pseudoinvo(k,id,Eo);
count:=2;
v:=cent(i,x,id,Eo);
remained:=ds(Group(ds(Group(cent(t,Group(v),id,Eo)))));
finished:=false;
  while not finished do
    if count=2 then
      involist[2]:=zeta0(involist[1],x,id,Eo);
      c:=ds(Group(cent(involist[2],x,id,Eo)));
      involist[2]:=involist[2]*involist[1];
      g:=isclassicalinvo(l,involist[2],i,id,Eo);
        if g[1]=true then
          tt:=t^g[2];
          sp4:=ds(Group(normalclosure(t,c)));
          splist[2]:=ds(Group(ds(Group(cent(t*tt,Group(sp4),id,Eo)))));
          ######################
          Info(InfoCPT,1,"1st short root fundamental SL2 is constructed.");
          ######################
          count:=count+1;
          ttt:=tt;
        fi;
    else
      involist[count]:=zeta0(involist[(count-1)],Group(remained),id,Eo);
      c:=ds(Group(cent(involist[count],x,id,Eo)));
      involist[count]:=involist[count]*involist[(count-1)];
      g:=isclassicalinvo(l,involist[count],i,id,Eo);
        if g[1]=true then
          tt:=t^g[2];
          sp4:=normalclosure(ttt,c);
          splist[count]:=ds(Group(ds(Group(cent(tt*ttt,Group(sp4),id,Eo)))));
            if count=3 then
              ######################
              Info(InfoCPT,1,"2nd short root fundamental SL2 is constructed.");
              ######################
            elif count=4 then
              ######################
              Info(InfoCPT,1,"3rd short root fundamental SL2 is constructed.");
              ######################
            else
              ######################
              Info(InfoCPT,1,count-1,"th short root fundamental SL2 is constructed.");
              ######################
            fi;
          v:=cent(involist[(count-1)],Group(remained),id,Eo);
          remained:=ds(Group(ds(Group(cent(ttt,Group(v),id,Eo)))));
          count:=count+1;
          ttt:=tt;
          kk:=1;
          found:=false;
          ii:=invo(remained,id,Eo);                                            
            while (kk<=10) and (not found) do
              iii:=invo(remained,id,Eo);
                if iii=ii then
                  kk:=kk+1;
                else
                  found:=true;
                fi;
            od;
            if (not found) then
              splist[count]:=remained;
              ######################
              Info(InfoCPT,1,"The extra node in the extended Dynkin diagram is constructed.");
              ######################
              ####################
              Info(InfoCPT,1,"The group is of type C_",count-1," together with an extended Curtis-Tits or extended Phan system.");
              ####################
              return splist;
            fi;

        fi;
    fi;
  od;
end;
################################################################################
################################################################################
################################################################################
cptforson:=function(l,c1,t1,k1,k2,i1,i2,id,Eo)
# returns a list of set of generators of subgroups isomorphic to SL_2 corresponding
# to the extended Curtis-Tits or (pseudo) Phan system. The last entry of the
# output list corresponds to the extra node.
# Here the list "l" is a list of generators for an orthogonal group.
# the lists "k1" and "k2" are fundamental SL2's corresponding to the fork in the
# extended Dynkin diagram.
# "i1" and "i2" are the central involutions in these groups.
# "t1" is a pseudo-involution in the group generated by "k1".
# "c1" is a set of generators of the semisimple socle of the centralizer of "t1"
# in the centralizer of "i1" in the group generated by "l".

local finished,listsl2,listinvo,remained,t2,count,k,classicheck,kk1,finished2,x;

x:=Group(l);
listsl2:=[];
listinvo:=[];
remained:=[];
listsl2[1]:=k1;
listsl2[2]:=k2;
listinvo[1]:=i1;
listinvo[2]:=i2;
remained[1]:=c1;
t2:=pseudoinvo(k2,id,Eo);
remained[2]:=ds(Group(ds(Group(cent(t2,Group(remained[1]),id,Eo)))));
count:=2;
finished:=false;
while (not finished) do
  if count=2 then
    finished2:=false;
    k:=1;
      while (not finished2) and (k<= 20) do
        listinvo[(count+1)]:=glueinvo(l,listsl2[count],listinvo[count],id,Eo);
        classicheck:=isclassicalinvo(l,listinvo[(count+1)],listinvo[count],id,Eo);
          if classicheck[1]=true then
            finished2:=true;
            listsl2[(count+1)]:=conjsub(listsl2[(count)],classicheck[2]);
            count:=count+1;
            ################
            Info(InfoCPT,1,"3rd fundamental SL_2-subgroup is constructed.");
            ################
          else
            k:=k+1;
          fi;
      od;
      if (not finished2) then                                       
        listsl2[3]:=ds(Group(ds(Group(cent(t1*t2,x,id,Eo)))));
        ####################
        Info(InfoCPT,1,"The group is of type B_2 together with an extended Curtis-Tits or extended Phan system.");
        ####################
        return Reversed(listsl2);
      fi;
  else
    if (not istrivialgroup(remained[(count-1)],id)) then
      finished2:=false;
      k:=1;
      while (not finished2) and (k<= 20) do
        listinvo[(count+1)]:=glueinvo(remained[(count-1)],listsl2[count],listinvo[count],id,Eo);
        classicheck:=isclassicalinvo(l,listinvo[(count+1)],listinvo[count],id,Eo);
          if classicheck[1]=true then
            finished2:=true;
            listsl2[(count+1)]:=conjsub(listsl2[(count)],classicheck[2]);
            count:=count+1;
              if count=3 then
                ##################
                Info(InfoCPT,1,"3rd fundamental SL_2-subgroup is constructed.");
                ##################
              else
                ##################
                Info(InfoCPT,1,count,"th fundamental SL_2-subgroup is constructed.");
                ##################
              fi;
          else
            k:=k+1;
          fi;
      od;
        if (not finished2) then
            listsl2[(count+1)]:=remained[(count-1)];
            listinvo[(count+1)]:=zeta0(listinvo[count],Group(listsl2[(count+1)]),id,Eo);
            if count mod 2 = 1 then
              ####################
              Info(InfoCPT,1,"The group is of type B_",count, " together with an extended Curtis-Tits or extended Phan system.");
              ####################
              return Reversed(listsl2);
            else
              ####################
              Info(InfoCPT,1,"There are two possibilities to conclude from the construction:");
              Info(InfoCPT,1,"1. The group is of type B_",count, " together with an extended Curtis-Tits or extended Phan system, or");
              Info(InfoCPT,1,"2. The group is of type D_",(count+1), " together with an extended pseudo-Phan system.");
              ####################
              return Reversed(listsl2);
            fi;
        else
          remained[(count-1)]:=ds(Group(ds(Group(cent(listinvo[(count-1)],remained[(count-2)],id,Eo)))));
        fi;
    else                                                                
          kk1:=twosl2(remained[(count-2)],id,Eo);
          listsl2[count]:=kk1[1];
          listsl2[(count+1)]:=kk1[2];
              if (count mod 2 = 0) then
                #########################
                Info(InfoCPT,1, "The group is of type D_", count, " together with an extended Curtis-Tits or extended Phan system.");
                #########################
              else
                #########################
                Info(InfoCPT,1, "The group is of type D_", count, " together with an extended Curtis-Tits system.");
                #########################
              fi;
          return Reversed(listsl2);
    fi;
  fi;
od;
end;
################################################################################
################################################################################
################################################################################
CPT:=function(l,E)
# construct a Curtis-Phan-Tits system for the group generated by the list "l".
# Here, "E" is an exponent of the group.
# returns a list of generators of subgroups corresponding to the nodes in the extended
# Dynking diagram of the algebraic group.

local x,id,L,k,finished,Ee,Eo,count,finished2,listinvo,listsl2,remained,prosl2,singlesl2,isrootsl2,checksp,k1,i1,v1,c1,f1,d1,s1,t1,vv1,cc1,ff1,dd1,ss1,t2,vv2,cc2,ff2,dd2,isorthogonal,classicheck,g,k1g;

x:=Group(l);
id:=Identity(x);
L:=E;                                                                 
k:=0;
finished:=false;
  while not finished do
    if L mod 2 = 0 then
      L:=L/2;
      k:=k+1;
    else
      finished:=true;
    fi;
  od;
Ee:=k;
Eo:=E/(2^Ee);
count:=0;
k:=1;
finished:=false;
finished2:=false;
listinvo:=[];
listsl2:=[];
remained:=[];
  while not finished do                                              
    while (not finished2) do
      prosl2:=sl2s(l,id,Eo);
      ###################
      Info(InfoCPT,1,"Commuting product of (P)SL2's is constructed.");
      ###################
      singlesl2:=sl2(prosl2,id,Eo);
        if singlesl2=false then
          #########################
          Info(InfoCPT,1,"There is no central involution in the commuting product. We restart from the beginning.");
          #########################
          finished2:=false;
        else
          finished2:=true;
        fi;
    od;
    isrootsl2:=rootsl2(l,singlesl2,id,Eo);
      if isrootsl2[1]=true then
        count:=count+1;
        listinvo[count]:=isrootsl2[2];
        listsl2[count]:=singlesl2;
        finished:=true;
        ####################
        Info(InfoCPT,1,"A fundamental SL2-subgroup is constructed.");
        ####################
      else
        finished2:=false;
      fi;
  od;
checksp:=glueinvo(l,listsl2[1],listinvo[1],id,Eo);                              
  if checksp=false then
    #####################
    Info(InfoCPT,1,"The group is of symplectic type.");
    #####################
    return cptforspn(l,listsl2[1],listinvo[1],id,Eo);
  fi;
k1:=singlesl2;                                                                  
i1:=isrootsl2[2];
v1:=cent(i1,x,id,Eo);
c1:=Group(v1);
f1:=ds(c1);
d1:=Group(f1);
s1:=ds(d1);
t1:=pseudoinvo(k1,id,Eo);
vv1:=cent(t1,Group(s1),id,Eo);
cc1:=Group(vv1);
ff1:=ds(cc1);
dd1:=Group(ff1);
ss1:=ds(dd1);
remained[1]:=ss1;
finished:=false;
k:=1;
isorthogonal:=false;                                                            
  while (not finished) and k<=20 do
    g:=PseudoRandom(c1);
    k1g:=conjsub(k1,g);
      if docommute(k1,k1g) then
        finished:=true;
        count:=count+1;
        isorthogonal:=true;
        ######################
        Info(InfoCPT,1,"The group is of orthogonal type.");
        ######################
        ##################
        Info(InfoCPT,1,"2nd fundamental SL_2-subgroup is constructed.");
        ##################
        return cptforson(l,ss1,t1,k1,k1g,i1,i1^g,id,Eo);
      else
        k:=k+1;
      fi;
  od;
finished:=false;
  while (not finished) do                                                       
    if count=1 then
      if (not istrivialgroup(remained[1],id)) then
        finished2:=false;
        k:=1;
          while (not finished2) and (k<= 20) do
            listinvo[(count+1)]:=glueinvo(l,listsl2[count],listinvo[count],id,Eo);
            classicheck:=isclassicalinvo(l,listinvo[(count+1)],listinvo[count],id,Eo);
              if classicheck[1]=true then
                finished2:=true;
                listsl2[(count+1)]:=conjsub(listsl2[(count)],classicheck[2]);
                count:=count+1;
                #######################
                Info(InfoCPT,1,"2nd fundamental SL_2-subgroup is constructed.");
                #######################
              else
                k:=k+1;
              fi;
          od;
          if (not finished2) then
            ######################
            Info(InfoCPT,1, "A classical involution can not be constructed. Construction is failed at the moment!");
            ######################
            return fail;
          fi;
      else                                                                 
        finished:=false;
          while (not finished) do
            listinvo[2]:=glueinvo(l,listsl2[1],listinvo[1],id,Eo);
            classicheck:=isclassicalinvo(l,listinvo[2],listinvo[1],id,Eo);
              if classicheck[1]=true then
                finished:=true;
                listsl2[2]:=conjsub(listsl2[1],classicheck[2]);
              fi;
          od;
        listinvo[3]:=listinvo[1]*listinvo[2];
        listsl2[3]:=ds(Group(ds(Group(cent(listinvo[3],x,id,Eo)))));
        ################
        Info(InfoCPT,1,"The group is of type A_2.");
        ################
        return listsl2;
      fi;
    else
      if (not istrivialgroup(remained[(count-1)],id)) then
        finished2:=false;
        k:=1;
          while (not finished2) and (k<= 20) do
            listinvo[(count+1)]:=glueinvo(remained[(count-1)],listsl2[count],listinvo[count],id,Eo);
            classicheck:=isclassicalinvo(l,listinvo[(count+1)],listinvo[count],id,Eo);
              if classicheck[1]=true then
                finished2:=true;
                listsl2[(count+1)]:=conjsub(listsl2[(count)],classicheck[2]);
                count:=count+1;
                  if count=3 then
                    ##################
                    Info(InfoCPT,1,"3rd fundamental SL_2-subgroup is constructed.");
                    ##################
                  else
                    ##################
                    Info(InfoCPT,1,count,"th fundamental SL_2-subgroup is constructed.");
                    ##################
                  fi;
              else
                k:=k+1;
              fi;
          od;
          if (not finished2) then
            ######################
            Info(InfoCPT,1, "A classical involution can not be constructed. Construction is failed at the moment!");
            ######################
            return fail;
          else
            v1:=cent(listinvo[(count-1)],remained[(count-2)],id,Eo);
            c1:=Group(v1);
            f1:=ds(c1);
            d1:=Group(f1);
            ss1:=ds(d1);
            remained[(count-1)]:=ss1;
          fi;
      else                                                                 
        g:=listinvo[1];
          for k in [2..Length(listinvo)] do
            g:=g*listinvo[k];
          od;
        listinvo[(count+2)]:=g;
        classicheck:=isclassicalinvo(l,g,listinvo[1],id,Eo);
          if classicheck[1]=true then
            finished2:=true;
            listsl2[(count+1)]:=conjsub(listsl2[1],classicheck[2]);
            ##################
            Info(InfoCPT,1, "The fundamental SL_2-subgroup for the extended Dynkin diagram is constructed.");
            ##################
          fi;
        ####################
        Info(InfoCPT,1,"The group is of type A_", count, " together with an extended Curtis-Tits system.");
        ####################
        return listsl2;
      fi;
    fi;
  od;
end;
